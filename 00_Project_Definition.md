# Doc 0: LightningFiler プロジェクト定義・基本設計書 (Ver 3.1)

## 1. プロジェクト概要

### 1.1 名称
**LightningFiler** (仮称)

### 1.2 定義
Windowsプラットフォームに特化した、**「超高速・高レスポンス・高カスタマイズ性」**を誇る画像ファイル管理統合環境。
「管理（Filer）」を主軸としつつ、現代のハードウェア性能を極限まで引き出した「閲覧（Viewer）」機能を内蔵する。
「あらゆる時代の、あらゆる言語のファイル」を、文字化けやクラッシュなく正確に扱い、既存のレガシービューアからの完全移行を可能にする。

### 1.3 ターゲットユーザー
*   ローカルストレージに数百万枚規模の画像・書庫ファイルを保有するパワーユーザー。
*   既存のビューア（QuickViewer, NeeView, MassiGra等）を使い分けているが、一本化したいと願う層。
*   日本語、英語のみならず、中国語（簡体字・繁体字）、ロシア語、韓国語など多言語のファイル名が混在する環境を持つ層。
*   Picasaのような「タグによる横断管理」と、Leeyesのような「キーボード/マウスによる高速選別」の両立を求める層。

## 2. 設計思想 (Core Philosophy)

### 2.1 Zero Latency (極限の速度)
*   **思考と操作の同期**: キー入力から描画更新までのレイテンシを、人間の知覚限界以下に抑える。
*   **非同期・並列化の徹底**: I/O、デコード、DBクエリ、サムネイル生成はすべてワーカースレッドで行い、UIスレッド（メインループ）はいかなる理由があってもブロックさせない。
*   **ネイティブ実装**: Rust + Win32 API/DirectX 12 (`wgpu`) を採用し、GC（ガベージコレクション）による停止を排除する。

### 2.2 Modular & Plugin with UI Hooks (拡張性とUI統合)
*   **マイクロカーネル**: コアは「ファイルシステム」「DB」「レンダリングエンジン」のみ。
*   **UI拡張可能なプラグイン**: AI解析やメタデータ表示などのプラグインは、単にデータを返すだけでなく、**「メインの描画パイプラインにオーバーレイを描画する」**権限を持つ。
    *   *例*: AIプラグインが、画像上の人物の顔に枠（バウンディングボックス）を直接描画する。
*   **レガシー継承**: 32bit Susieプラグイン資産を、共有メモリIPCを用いて安全かつ高速に利用する。

### 2.3 User Sovereignty & i18n (ユーザー主権と国際化)
*   **完全な制御**: `NeeView` の言語ファイルに見られるような、数百におよぶコマンド（移動、表示、ファイル操作）を全てID化し、ユーザーが任意のキー・マウス操作に割り当て可能とする。
*   **多言語対応 (i18n)**: 設計段階からマルチランゲージ（日本語/英語）を前提とする。
    *   UIテキスト、設定項目、エラーメッセージは全てリソースファイル（FluentまたはJSON）として分離し、ハードコーディングを禁止する。

### 2.4 Filer First, Viewer Complete (ファイラー特化・ビューア完備)
*   **統合環境**: 「管理はファイラー、見るのは外部ツール」という使い分けを強要しない。内蔵ビューアはQuickViewerと同等以上の速度と、NeeViewに近い機能性（見開き、書庫内閲覧）を備える。
*   **シームレスな移行**: ファイラーモード（グリッド）とビューアモード（1枚表示）を、モード切替のラグなしに行き来できる設計とする。

### 2.5 Tagging & Metadata Strategy (Picasaモデル)
*   **DB中心の管理**: ファイルパスに依存しない「タグ」による管理を主とする。
    *   数百万枚の画像に対し、瞬時に「タグA かつ タグB」の検索結果を表示する。
*   **仮想フォルダ**: タグ検索結果や、タイムライン（日付順）を、あたかも「フォルダ」であるかのように扱える仮想ファイルシステム（VFS）を実装する。
*   **非破壊とポータビリティ**:
    *   基本はSQLite内のメタデータとして管理（元画像を変更しない）。
    *   オプションで、XMP（サイドカーファイル）への書き出しや、ファイル名へのタグ埋め込みをサポートする。

### 2.6 Universal Encoding & Text Handling (文字コードの完全掌握)
*   **Legacy Archive Rescue**: ZIP/LZH/RAR等の書庫内で、UTF-8フラグが立っていないファイル名に対し、自動判別（chardet）を行う。
    *   さらに、ユーザーが「この書庫はGBKで読み直す」「これはShift-JIS」と**強制指定できる機能（Encoding Override）**を実装する。
*   **Robust Path Handling**: Windowsのファイルパス（WTF-16）を、RustのUTF-8 (`String`) と安易に相互変換せず、OSネイティブな表現 (`OsString`) として可能な限り維持する。
    *   「表示できない文字」があっても、ファイルアクセスやコピー・移動は成功させなければならない。
*   **Unicode Normalization**: 検索インデックス（DB）においては、NFC/NFDの揺らぎを吸収し、「が」と「か+゛」を同一視して検索可能にする。
*   **Glyph Fallback**: 描画エンジンは、システムフォント（Meiryo, Yu Gothic等）だけでなく、不足しているグリフ（中国語フォント、絵文字フォント）を自動的に探し出して表示する「フォールバック機能」を完備する。豆腐（□）を表示させない。

## 3. システム全体像とドキュメント構成

### 【Doc 1】 システムアーキテクチャ定義書 (`01_Architecture.md`)
**「どう動くか」** - ソフトウェアの骨格。
*   **プロセスモデル**: Main(64bit) ⇔ Susie Bridge(32bit) ⇔ Plugin Host。
*   **スレッドモデル**: `tokio` ランタイムと `rayon` スレッドプールの使い分け。
*   **メモリ管理**: `Unsafe` 領域と `wgpu` バッファのマッピング戦略。
*   **国際化基盤**: 言語リソースのロードと動的切り替えの仕組み。

### 【Doc 2】 データベース・ファイルシステム仕様書 (`02_Database_FileSystem.md`)
**「どう保存するか」** - 数百万ファイルの基盤。
*   **DBスキーマ**: Files, Tags, FileTags (多対多), History のテーブル設計。
*   **KVS設計**: RocksDBによるサムネイルキャッシュと、画像ハッシュ（重複検出用）の管理。
*   **仮想ファイルシステム (VFS)**:書庫内ファイル名のエンコーディング解決ロジックを含むパス解決


### 【Doc 3】 入力・操作カスタマイズ仕様書 (`03_Input_UX.md`)
**「どう操作するか」** - ユーザーインターフェースの魂。
*   **Command ID Registry**: NeeViewの言語ファイルを参考に、実装すべき全コマンドのリスト化。
*   **Input Dispatcher**: キー/マウス/ジェスチャ/ゲームパッド入力をコマンドへ変換するロジック。
*   **Context System**: 「ビューアで右クリックした時」と「リストで右クリックした時」の挙動分離。

### 【Doc 4】 UI/レンダリング仕様書 (`04_UI_Rendering.md`)
**「どう見せるか」** - 高速描画と拡張性。
*   **Text Rendering**: `cosmic-text` や `DirectWrite` を用いた、多言語・絵文字対応のテキスト描画パイプライン。
*   **GUIフレームワーク**: `egui` + `wgpu`。
*   **Plugin UI Hooks**: プラグインが「設定画面」「サイドパネル」「画像オーバーレイ」にUIを注入するためのAPI仕様。
*   **Viewer Logic**: 見開き判定、先読み、高画質縮小（Lanczos等）のシェーダーパイプライン。

### 【Doc 5】 拡張・プラグイン仕様書 (`05_Extension_API.md`)
**「どう広げるか」** - 将来性。
*   **Native Plugin API (Rust/C ABI)**: 高速な画像処理用。
*   **Scripting (Optional)**: ユーザー定義の簡易スクリプト（Lua または Rhai を検討）。
*   **Legacy Bridge**: Susie APIの詳細仕様。

## 補足検討事項


「文字コードの完全掌握」と「Picasaモデル」が追加されたことで、仕様はより強固になりましたが、Windows特有の「地雷」を踏まないために、以下の2点を補足検討事項として挙げます。

#### 1. 「Windowsで作成できないファイル名」の救済 (Sanitization Strategy)
*   **課題**: Linux/Macで作成されたZip内には、Windowsのファイルシステムで禁止されている文字（`:` `*` `?` `"` `<` `>` `|`）や、予約語（`CON`, `PRN`, `AUX`）が含まれるファイルが存在します。
*   **アドバイス**:
    *   VFS（仮想ファイルシステム）上では、これらを「そのまま」扱えるようにすべきですが、**「解凍して実体化」する際や「一時フォルダに展開」する際のサニタイズ（無害化）ルール**を厳密に定義する必要があります。
    *   *例*: `image:01.jpg` → `image_01.jpg` (全角置換するか、アンダースコアにするか、ユーザー設定で選ばせるか)

#### 2. 「物理フォルダ」と「論理ビュー（タグ/検索）」の操作一貫性
*   **課題**: 「次のファイルへ移動」というコマンド一つとっても、文脈によって挙動が変わります。
    *   物理フォルダ閲覧時: ファイルシステム順の次のファイル。
    *   タグ検索結果閲覧時: **DBの検索結果リスト順**の次のファイル（物理的には別のドライブにあるかもしれない）。
*   **アドバイス**:
    *   Doc 3を作成する際、コマンドを定義するだけでなく、そのコマンドが**「どのコンテキスト（物理/論理）で有効か」**、あるいは**「コンテキストによってどう挙動を変えるか」**を明記する必要があります。Leeyesはこのあたりが暗黙的にうまく処理されていますが、新規開発では明示的な設計が必要です。





3. UI実装の落とし所（初期 vs 将来）
アーキテクチャはマルチ対応にしておきつつ、UIの露出は制御します。
Phase 1 (初期):
シングルビューのみ。ただし内部的には views[0] を表示しているだけ。
Phase 2 (比較機能):
**「画面分割（Split View）」**をサポート。
別ウィンドウ（Multi-Window）を立ち上げるのではなく、1つのウィンドウ内で左右に並べる（ファイラーの2画面モードの応用）。これなら egui のドッキング機能で容易に実装でき、OSのリソースも食いません。
Phase 3 (マルチウィンドウ):
必要であれば、ViewContext を切り離して別のOSウィンドウに渡す（Pop-out）。
4. 仕様書への反映
この判断に基づき、Doc 1 (アーキテクチャ) と Doc 4 (UI) に以下の定義を組み込むべきです。
Doc 1: システムアーキテクチャ定義書 への追加事項
View Stateの分離:
「グローバルな設定（キーバインド、配色）」と「ローカルな表示状態（ズーム、位置）」を厳密に区別する。
共有リソース管理:
複数のビューアが同じ画像を表示した際、VRAM上のテクスチャを二重に生成しない「参照カウント方式」のキャッシュ管理。
Doc 4: UI/レンダリング仕様書 への追加事項
比較モード (Compare Mode):
将来的に「左右分割」や「透過重ね合わせ（Onion Skin）」ができる余地を残す。
同期スクロール: 2つの画像を並べて、片方をズーム/パンしたらもう片方も追従する機能（比較に必須）。